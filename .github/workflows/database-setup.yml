name: Database Setup

on:
  workflow_dispatch:
    inputs:
      tenant:
        description: 'Tenant name'
        required: true
        type: string
      bastion_ip:
        description: 'Bastion Host Public IP'
        required: true
        type: string
      db_endpoint:
        description: 'RDS Endpoint'
        required: true
        type: string

jobs:
  db-setup:
    runs-on: ubuntu-latest
    environment: production

    env:
      TENANT: ${{ inputs.tenant }}
      BASTION_IP: ${{ inputs.bastion_ip }}
      DB_ENDPOINT: ${{ inputs.db_endpoint }}

    steps:
      - name: Validate Inputs
        run: |
          if [[ -z "$TENANT" || -z "$BASTION_IP" || -z "$DB_ENDPOINT" ]]; then
            echo "Missing required input"
            exit 1
          fi
          echo "Setting up 3 DBs + 4 roles for tenant: $TENANT"

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: eu-north-1

      # ──────────────────────────────────────────────────────────────
      # 1. Generate 4 Secure Passwords
      # ──────────────────────────────────────────────────────────────
      - name: Generate Login Role Passwords
        id: gen-pass
        run: |
          set -euo pipefail

          gen_pw() {
            LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
            printf '\n'
          }

          PASS_ANALYTICS=$(gen_pw)
          echo "PASS_ANALYTICS=$PASS_ANALYTICS" >> "$GITHUB_ENV"

          PASS_FIVETRAN=$(gen_pw)
          echo "PASS_FIVETRAN=$PASS_FIVETRAN" >> "$GITHUB_ENV"

          PASS_AI=$(gen_pw)
          echo "PASS_AI=$PASS_AI" >> "$GITHUB_ENV"

          PASS_APP=$(gen_pw)
          echo "PASS_APP=$PASS_APP" >> "$GITHUB_ENV"

      # ──────────────────────────────────────────────────────────────
      # 2. Save All 4 Roles to Secrets Manager
      # ──────────────────────────────────────────────────────────────
      - name: Save Analytics Role
        env:
          NAME: ${{ env.TENANT }}-analytics
          SECRET: tenant-role-${{ env.TENANT }}-analytics
          PAYLOAD: '{"username":"${{ env.TENANT }}-analytics","password":"${{ env.PASS_ANALYTICS }}"}'
        run: |
          # Create secret with correct tags (only if not exists)
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Primary login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=analytics Key=purpose,Value=primary \
            || true

          # Always update value
          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save Fivetran Role
        env:
          NAME: ${{ env.TENANT }}-fivetran
          SECRET: tenant-role-${{ env.TENANT }}-fivetran
          PAYLOAD: '{"username":"${{ env.TENANT }}-fivetran","password":"${{ env.PASS_FIVETRAN }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Fivetran sync role for $TENANT-analytics DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=analytics Key=purpose,Value=fivetran \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save AI Role
        env:
          NAME: ${{ env.TENANT }}-ai
          SECRET: tenant-role-${{ env.TENANT }}-ai
          PAYLOAD: '{"username":"${{ env.TENANT }}-ai","password":"${{ env.PASS_AI }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=ai \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save Application Role
        env:
          NAME: ${{ env.TENANT }}-application
          SECRET: tenant-role-${{ env.TENANT }}-application
          PAYLOAD: '{"username":"${{ env.TENANT }}-application","password":"${{ env.PASS_APP }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=application \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      # ──────────────────────────────────────────────────────────────
      # 3. Get DB Admin Credentials
      # ──────────────────────────────────────────────────────────────
      - name: Get DB Admin Credentials
        run: |
          SECRET_NAME="prod-${TENANT}-database-rds-connection"
          CREDS_JSON=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text)
          
          # Extract username and password field
          ADMIN_USER=$(echo "$CREDS_JSON" | jq -r .username)
          PASS_FIELD=$(echo "$CREDS_JSON" | jq -r .password_ref)

          # If password is an ARN → fetch real password
          if [[ "$PASS_FIELD" =~ ^arn:aws:secretsmanager: ]]; then
            echo "Resolving nested secret ARN..."
            REAL_PASS=$(aws secretsmanager get-secret-value --secret-id "$PASS_FIELD" --query SecretString --output text | jq -r .password)
          else
            REAL_PASS="$PASS_FIELD"
          fi

          echo "ADMIN_USER=$ADMIN_USER" >> $GITHUB_ENV
          echo "ADMIN_PASS=$REAL_PASS" >> $GITHUB_ENV

      # ──────────────────────────────────────────────────────────────
      # 4. Install Tools & Get Bastion Key
      # ──────────────────────────────────────────────────────────────
      - name: Install Tools & Prepare Bastion Access
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client openssh-client tar gzip jq

          # 1. Get private key from SSM
          PEM=$(aws ssm get-parameter \
            --name "/bastion/prod/db-admin/private-key" \
            --with-decryption --query "Parameter.Value" --output text)

          echo "$PEM" > bastion.pem
          chmod 400 bastion.pem

          # 2. Derive public key from THIS EXACT private key
          PUB_KEY=$(ssh-keygen -y -f bastion.pem | awk '{print $1" "$2" db-admin-key"}')

          # 3. Add to bastion via SSM (idempotent)
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=$BASTION_IP" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text)

          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"$INSTANCE_ID\"]}]" \
            --parameters "commands=[
              \"mkdir -p /home/ubuntu/.ssh\",
              \"echo '$PUB_KEY' >> /home/ubuntu/.ssh/authorized_keys\",
              \"sort -u /home/ubuntu/.ssh/authorized_keys -o /home/ubuntu/.ssh/authorized_keys\",
              \"chmod 600 /home/ubuntu/.ssh/authorized_keys\",
              \"chown -R ubuntu:ubuntu /home/ubuntu/.ssh\"
            ]" \
            --comment "Add db-admin SSH key" \
            --timeout-seconds 60

          echo "Public key added to bastion (Instance ID: $INSTANCE_ID)"

      # ──────────────────────────────────────────────────────────────
      # 5. Execute SQL via Bastion
      # ──────────────────────────────────────────────────────────────
      - name: Execute SQL via Bastion
        run: |
          set -euo pipefail

          # 1. Bundle SQL files
          mkdir -p sql_bundle
          cp sql/*.sql sql_bundle/
          tar -czf sql_bundle.tar.gz sql_bundle/

          # 2. Upload to bastion
          scp -o StrictHostKeyChecking=no -i bastion.pem sql_bundle.tar.gz ubuntu@$BASTION_IP:/tmp/

          # 3. Run on bastion — FORCE REMOTE CONNECTION
          ssh -o StrictHostKeyChecking=no -i bastion.pem ubuntu@$BASTION_IP << 'EOF'
            set -e
            cd /tmp
            tar -xzf sql_bundle.tar.gz

            # === Export variables ===
            DB_ENDPOINT="$DB_ENDPOINT"
            ADMIN_USER="$ADMIN_USER"
            ADMIN_PASS="$ADMIN_PASS"
            TENANT="$TENANT"
            PASS_ANALYTICS="$PASS_ANALYTICS"
            PASS_FIVETRAN="$PASS_FIVETRAN"
            PASS_AI="$PASS_AI"
            PASS_APP="$PASS_APP"

            # === FULL psql command with -h and -U every time ===
            echo "Creating 3 databases for $TENANT"
            PGPASSWORD="$ADMIN_PASS" psql -h "$DB_ENDPOINT" -p 5432 -U "$ADMIN_USER" -d postgres -v ON_ERROR_STOP=1 -v tenant="$TENANT" -f sql_bundle/01_create_databases.sql

            # === Create login roles ===
            for suffix in analytics fivetran ai application; do
              case $suffix in
                analytics)   pass="$PASS_ANALYTICS" ;;
                fivetran)    pass="$PASS_FIVETRAN" ;;
                ai)          pass="$PASS_AI" ;;
                application) pass="$PASS_APP" ;;
              esac
              echo "Creating login role: $TENANT-$suffix"
              PGPASSWORD="$ADMIN_PASS" psql -h "$DB_ENDPOINT" -p 5432 -U "$ADMIN_USER" -d postgres -v ON_ERROR_STOP=1 -v tenant="$TENANT" -v suffix="$suffix" -v password="$pass" -f sql_bundle/02_create_login.sql
            done

            # === Grant permissions ===
            for suffix in analytics fivetran ai application; do
              echo "Granting permissions for $suffix"
              PGPASSWORD="$ADMIN_PASS" psql -h "$DB_ENDPOINT" -p 5432 -U "$ADMIN_USER" -d postgres -v ON_ERROR_STOP=1 -v tenant="$TENANT" -v suffix="$suffix" -f sql_bundle/03_grant_permissions.sql
            done

            # === Create schemas — inside target DB ===
            for suffix in analytics fivetran ai application; do
              echo "Creating schemas for $suffix"
              PGPASSWORD="$ADMIN_PASS" psql -h "$DB_ENDPOINT" -p 5432 -U "$ADMIN_USER" -d "$TENANT-$suffix" -v ON_ERROR_STOP=1 -v tenant="$TENANT" -v suffix="$suffix" -f sql_bundle/04_create_schemas.sql
            done

            echo "SUCCESS: 3 databases, 4 roles, permissions, and schemas created!"
          EOF