name: Database Setup

on:
  workflow_dispatch:
    inputs:
      tenant:
        description: 'Tenant name'
        required: true
        type: string
      bastion_ip:
        description: 'Bastion Host Public IP'
        required: true
        type: string
      db_endpoint:
        description: 'RDS Endpoint'
        required: true
        type: string

jobs:
  db-setup:
    runs-on: ubuntu-latest
    environment: production

    env:
      TENANT: ${{ inputs.tenant }}
      BASTION_IP: ${{ inputs.bastion_ip }}
      DB_ENDPOINT: ${{ inputs.db_endpoint }}

    steps:
      - name: Validate Inputs
        run: |
          if [[ -z "$TENANT" || -z "$BASTION_IP" || -z "$DB_ENDPOINT" ]]; then
            echo "Missing required input"
            exit 1
          fi
          echo "Setting up 3 DBs + 4 roles for tenant: $TENANT"

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: eu-north-1

      # ──────────────────────────────────────────────────────────────
      # 1. Generate 4 Secure Passwords
      # ──────────────────────────────────────────────────────────────
      - name: Generate Login Role Passwords
        id: gen-pass
        run: |
          set -euo pipefail

          gen_pw() {
            LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
            printf '\n'
          }

          PASS_ANALYTICS=$(gen_pw)
          echo "PASS_ANALYTICS=$PASS_ANALYTICS" >> "$GITHUB_ENV"

          PASS_FIVETRAN=$(gen_pw)
          echo "PASS_FIVETRAN=$PASS_FIVETRAN" >> "$GITHUB_ENV"

          PASS_AI=$(gen_pw)
          echo "PASS_AI=$PASS_AI" >> "$GITHUB_ENV"

          PASS_APP=$(gen_pw)
          echo "PASS_APP=$PASS_APP" >> "$GITHUB_ENV"

      # ──────────────────────────────────────────────────────────────
      # 2. Save All 4 Roles to Secrets Manager
      # ──────────────────────────────────────────────────────────────
      - name: Save Analytics Role
        env:
          NAME: ${{ env.TENANT }}-analytics
          SECRET: tenant-role-${{ env.TENANT }}-analytics
          PAYLOAD: '{"username":"${{ env.TENANT }}-analytics","password":"${{ env.PASS_ANALYTICS }}"}'
        run: |
          # Create secret with correct tags (only if not exists)
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Primary login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=analytics Key=purpose,Value=primary \
            || true

          # Always update value
          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save Fivetran Role
        env:
          NAME: ${{ env.TENANT }}-fivetran
          SECRET: tenant-role-${{ env.TENANT }}-fivetran
          PAYLOAD: '{"username":"${{ env.TENANT }}-fivetran","password":"${{ env.PASS_FIVETRAN }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Fivetran sync role for $TENANT-analytics DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=analytics Key=purpose,Value=fivetran \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save AI Role
        env:
          NAME: ${{ env.TENANT }}-ai
          SECRET: tenant-role-${{ env.TENANT }}-ai
          PAYLOAD: '{"username":"${{ env.TENANT }}-ai","password":"${{ env.PASS_AI }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=ai \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      - name: Save Application Role
        env:
          NAME: ${{ env.TENANT }}-application
          SECRET: tenant-role-${{ env.TENANT }}-application
          PAYLOAD: '{"username":"${{ env.TENANT }}-application","password":"${{ env.PASS_APP }}"}'
        run: |
          aws secretsmanager create-secret \
            --name "$SECRET" \
            --secret-string "$PAYLOAD" \
            --description "Login for $NAME DB" \
            --tags Key=tenant,Value=$TENANT Key=db,Value=application \
            || true

          aws secretsmanager put-secret-value \
            --secret-id "$SECRET" \
            --secret-string "$PAYLOAD" \
            --version-stages AWSCURRENT

      # ──────────────────────────────────────────────────────────────
      # 3. Get DB Admin Credentials
      # ──────────────────────────────────────────────────────────────
      - name: Get DB Admin Credentials
        run: |
          SECRET_NAME="prod-${TENANT}-database-rds-connection"
          CREDS_JSON=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text)
          
          # Extract username and password field
          ADMIN_USER=$(echo "$CREDS_JSON" | jq -r .username)
          PASS_FIELD=$(echo "$CREDS_JSON" | jq -r .password_ref)

          # If password is an ARN → fetch real password
          if [[ "$PASS_FIELD" =~ ^arn:aws:secretsmanager: ]]; then
            echo "Resolving nested secret ARN..."
            REAL_PASS=$(aws secretsmanager get-secret-value --secret-id "$PASS_FIELD" --query SecretString --output text | jq -r .password)
          else
            REAL_PASS="$PASS_FIELD"
          fi

          echo "ADMIN_USER=$ADMIN_USER" >> $GITHUB_ENV
          echo "ADMIN_PASS=$REAL_PASS" >> $GITHUB_ENV

      # ──────────────────────────────────────────────────────────────
      # 4. Install Tools & Get Bastion Key
      # ──────────────────────────────────────────────────────────────
      - name: Install Tools & Prepare Bastion Access
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client openssh-client tar gzip jq

          # 1. Get private key from SSM
          PEM=$(aws ssm get-parameter \
            --name "/bastion/prod/db-admin/private-key" \
            --with-decryption --query "Parameter.Value" --output text)

          echo "$PEM" > bastion.pem
          chmod 400 bastion.pem

          # 2. Derive public key from THIS EXACT private key
          PUB_KEY=$(ssh-keygen -y -f bastion.pem | awk '{print $1" "$2" db-admin-key"}')

          # 3. Add to bastion via SSM (idempotent)
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=$BASTION_IP" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text)

          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"$INSTANCE_ID\"]}]" \
            --parameters "commands=[
              \"mkdir -p /home/ubuntu/.ssh\",
              \"echo '$PUB_KEY' >> /home/ubuntu/.ssh/authorized_keys\",
              \"sort -u /home/ubuntu/.ssh/authorized_keys -o /home/ubuntu/.ssh/authorized_keys\",
              \"chmod 600 /home/ubuntu/.ssh/authorized_keys\",
              \"chown -R ubuntu:ubuntu /home/ubuntu/.ssh\"
            ]" \
            --comment "Add db-admin SSH key" \
            --timeout-seconds 60

          echo "Public key added to bastion (Instance ID: $INSTANCE_ID)"

      # ──────────────────────────────────────────────────────────────
      # 5. Execute SQL via Bastion
      # ──────────────────────────────────────────────────────────────
      - name: Execute SQL via Bastion
        run: |
          mkdir -p sql_bundle
          cp sql/01_create_databases.sql \
             sql/02_create_login.sql \
             sql/03_grant_permissions.sql \
             sql/04_create_schemas.sql \
             sql_bundle/

          tar -czf sql_bundle.tar.gz sql_bundle/
          scp -o StrictHostKeyChecking=no -i bastion.pem sql_bundle.tar.gz ubuntu@$BASTION_IP:/tmp/

          ssh -o StrictHostKeyChecking=no -i bastion.pem ubuntu@$BASTION_IP << 'EOF'
            set -e
            cd /tmp
            tar -xzf sql_bundle.tar.gz

            export PGPASSWORD='$ADMIN_PASS'
            export PSQL="psql -h $DB_ENDPOINT -U $ADMIN_USER -d postgres -v ON_ERROR_STOP=1"

            # 1. Create 3 databases
            echo "Creating 3 databases for $TENANT"
            $PSQL -v tenant="$TENANT" -f sql_bundle/01_create_databases.sql

            # 2. Create 4 LOGIN roles (using 02_create_login.sql)
            echo "Creating login role: ${TENANT}-analytics"
            $PSQL -v tenant="$TENANT" -v suffix="analytics" -v password="$PASS_ANALYTICS" -f sql_bundle/02_create_login.sql

            echo "Creating login role: ${TENANT}-fivetran"
            $PSQL -v tenant="$TENANT" -v suffix="fivetran" -v password="$PASS_FIVETRAN" -f sql_bundle/02_create_login.sql

            echo "Creating login role: ${TENANT}-ai"
            $PSQL -v tenant="$TENANT" -v suffix="ai" -v password="$PASS_AI" -f sql_bundle/02_create_login.sql

            echo "Creating login role: ${TENANT}-application"
            $PSQL -v tenant="$TENANT" -v suffix="application" -v password="$PASS_APP" -f sql_bundle/02_create_login.sql

            # 3. Grant permissions + create DB roles (using 03_grant_permissions.sql)
            #    This script uses :tenant and :suffix to:
            #    - Connect to correct DB
            #    - Create DB-local role
            #    - Grant permissions
            echo "Granting DB permissions for analytics (primary)"
            $PSQL -v tenant="$TENANT" -v suffix="analytics" -f sql_bundle/03_grant_permissions.sql

            echo "Granting DB permissions for fivetran (in analytics DB)"
            $PSQL -v tenant="$TENANT" -v suffix="fivetran" -f sql_bundle/03_grant_permissions.sql

            echo "Granting DB permissions for ai"
            $PSQL -v tenant="$TENANT" -v suffix="ai" -f sql_bundle/03_grant_permissions.sql

            echo "Granting DB permissions for application"
            $PSQL -v tenant="$TENANT" -v suffix="application" -f sql_bundle/03_grant_permissions.sql

            # 4. Create schemas (optional, if needed per DB)
            for suffix in analytics fivetran ai application; do
              echo "Creating schemas in ${TENANT}-${suffix} DB"
              $PSQL -v tenant="$TENANT" -v suffix="$suffix" -f sql_bundle/04_create_schemas.sql
            done

            echo "All done: 3 DBs, 4 login roles, DB-local roles + grants"
          EOF